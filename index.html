<!-- TODO -->
<!-- DONE: Make the sidebar resizable -->
<!-- DONE: Sometimes subtitles aren't parsed because their filename uses .ASS instead of .ass, and fluentcards fails on this -->
<!-- Fix the main subtitle pane so it doesn't prevent you from clicking play -->
<!-- DONE: Put an options bar at the bottom that expands and collapses -->
<!-- DONE: Put a subtitle shift button in the options -->
<!-- DONE: Make error messages specific to subtitle or video errors -->
<!-- Make the app a single html page -->
<!-- DONE: If you use yomichan to add a word from the sidebar, 
     it should only put a single caption into the sentence field in anki, 
     not every visible caption on the page -->
<!-- Make the arrow keys work -->
<!-- Make the arrow keys not shift any more than X seconds max -->
<!-- DONE: Make LoGH subs load up by default; newlines are tricky -->
<!-- Make double click hide sidebar? -->
<!-- Make resize bar area bigger -->

<!DOCTYPE html>
<html>
  <head>
    <title>Animebook</title>
    <style>
      html,
      body,
      #app,
      .drop-wrapper,
      .app-container {
        height: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: #fff;
        font-family: Helvetica, sans-serif;
      }

      .drop-wrapper {
        transition: background-color 100ms ease-out;
      }

      .drop-wrapper.dragging-file {
        opacity: 0.4;
      }

      .app-container {
        display: grid;
      }

      .video-subtitles-missing {
        grid-area: video;
      }

      .video-missing, .video-error {
        grid-area: video;
        position: relative;
      }

      .subtitles-missing, .subtitles-error {
        grid-area: captions;
        position: relative;
      }

      .video-container {
        grid-area: video;
        position: relative;
      }

      .video-element {
        max-height: 100vh;
        width: 100%;
      }

      .sidebar-captions {
        grid-area: captions;
        position: relative;
      }

      .captions-container {
        height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
        background-color: black;
        color: #333;
        position: relative
      }

      .caption {
        font-size: 16px;
        cursor: pointer;
        margin: 0;
        padding: 1em;
        transition: background-color 100ms linear;
      }

      .caption:hover {
        background-color: #91aab1;
        color: black;
      }

      .caption.active {
        transition: background-color 300ms linear;
        background-color: #59757d;
        color: black;
      }

      .current-caption {
        font-size: 20px;
        text-align: center;
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #808080;
        z-index: 2;
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        paint-order: stroke;
        -webkit-text-stroke: unset;
        text-shadow: 0.05em 0 black, 0 0.05em black, -0.05em 0 black,
          0 -0.05em black, -0.05em -0.05em black, -0.05em 0.05em black,
          0.05em -0.05em black, 0.05em 0.05em black;
      }

      .resize-bar-wrapper {
        grid-area: resizeBar;
        height: 100%;
        position: relative;
      }

      .resize-bar {
        position: absolute;
        height: 100%;
        top: 0px;
        left: -3px;
        width: 6px;
        cursor: ew-resize;
      }

      .controls {
        grid-area: controls;
        display: flex;
        flex-direction: row;
        width: 100%;
        height: 100%;
        color: #444;
      }

      .offset-input {
        border: 0;
        color: #444;
        background-color: #060606;
        font-size: 1.5vh;
        text-align: center;
        width: 10px;
        flex: 1 1 50%;
        box-sizing: border-box;
        border-left: 1px solid black;
      }

      .offset-button {
        padding: .2rem;
        font-size: 1.5vh;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        cursor: pointer;
        transition: background-color 100ms linear;
        box-sizing: border-box;
        overflow: hidden;
        cursor: pointer;
        flex: 1 1 50%;
      }

      .offset-button.off {
        background-color: #060606;
      }

      .offset-button.off:hover {
        background-color: #91aab1;
        color: black;
      }

      .offset-button.on {
        background-color: #300;
      }

      .offset-button.on:hover {
        background-color: #7d0909;
        color: black;
      }

      .caption-time-offset {
        position: absolute;
        top: 0;
        right: 2px;
        font-size: 10px;
        color: #644
      }

      .caption-time-offset:hover {
        color: #200;
      }

      .controls-expand {
        grid-area: controlsExpand;
        box-sizing: border-box;
        cursor: pointer;
        text-align: center;
        position: relative;
        transition: background-color 100ms linear;
        width: 100%;
      }

      .controls-expand.open {
        background-color: #0A0A0A;
      }

      .controls-expand.closed {
        background-color: black;
      }

      .controls-expand:hover {
        background-color: #91aab1;
      }

      .hint {
        font-size: 22px;
        letter-spacing: 1.1px;
        word-spacing: 0.05em;
        line-height: 1.5;
        font-weight: normal;
        position: absolute;
        top: 20%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 600px;
        text-align: center;
      }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  </head>
  <body>
    <div
      id="app"
      @keyup.space.stop.prevent="playPause"
      @keyup.enter.stop.prevent="replayCaption"
      @keyup.left.stop.prevent="previousCaption"
      @keyup.up.stop.prevent="previousCaption"
      @keyup.right.stop.prevent="nextCaption"
      @keyup.down.stop.prevent="nextCaption"
      @mouseup="onMouseUp"
      @mousemove="onMouseMove"
      @mouseout="onMouseOut"
    >
      <div
        class="drop-wrapper"
        :class="dropWrapperClass"
        @dragover.stop.prevent="onFileDragover"
        @dragleave.stop.prevent="onFileDragleave"
        @drop.stop.prevent="onFileDrop"
      >
        <div class="app-container" :style="calcAppStyle()">
          <div class="video-subtitles-missing hint" v-show="!videoUrl && !captionsUrl">
            Drag-and-drop a video file and the corresponding subtitles file to
            this page
          </div>
          <div class="video-missing" v-show="!videoUrl && captionsUrl && !shouldShowVideoError">
            <div class="hint">
              Drag-and-drop a video file
            </div>
          </div>
          <div class="subtitles-missing" v-show="videoUrl && !captionsUrl && !shouldShowSubtitlesError">
            <div class="hint">
            Drag-and-drop a subtitles file<br />(vtt, srt or ass)
            </div>
          </div>
          <div class="video-error" v-show="shouldShowVideoError">
            <div class="hint">
              There was an error loading the video file {{videoFileName}}. Note that web players do not support support H.265 video or AC3 audio.
            </div>
          </div>
          <div class="subtitles-error" v-show="shouldShowSubtitlesError">
            <div class="hint">
              There was an error parsing the subtitles file {{subtitlesFileName}}.
              <span v-if="subtitlesError">{{subtitlesError}}</span>
            </div>
          </div>
          <div class="video-container" v-show="videoUrl && !shouldShowVideoError">
            <video
              id="video-element"
              class="video-element"
              :src="videoUrl"
              @error="onVideoError"
              @timeupdate="onTimeUpdate"
              crossorigin="anonymous"
              controls
              disablePictureInPicture
            >
              <track
                kind="subtitles"
                :src="captionsUrl"
                @load="onCaptionsLoad"
                @cuechange="onCaptionsCueChange"
                default
              />
            </video>

            <span class="current-caption" v-html="'\n' + displayedText + '\n'"></span>
          </div>
          <div class="resize-bar-wrapper">
            <div 
              class="resize-bar"
              @mousedown.stop.prevent="onResizeBarMouseDown">
            </div>
          </div>
          <div class="sidebar-captions" v-if="captionsUrl">
            <div class="captions-container">
              <div v-for="(caption, index) in captions" style="position: relative;">
                <div
                  :id="caption.id"
                  :class="captionStyle(caption, index)"
                  @click="selectCaption(caption)"
                  v-html="'' + caption.text + '\n'">
                </div>
                <div v-if="isOffsetMode" class='caption-time-offset' v-html="displayCaptionOffset(caption)"></div>
              </div>
            </div>
          </div>
          <div v-if="captionsUrl" :class="controlsExpandClass" @click="toggleControls()">
          </div>
          <div v-if="captionsUrl" class="controls">
            <a :class="offsetButtonClass" @click="toggleOffsetMode()"><span>{{this.isOffsetMode ? 'Cancel' : 'Offset Subtitles'}}</span></a>
            <input class="offset-input" v-model="subtitlesOffsetInput"></input>
          </div>
        </div>
      </div>
    </div>

    <script>
      new Vue({
        el: "#app",
        data: {
          videoUrl: null,
          subtitlesFileContent: null,
          subtitlesOffsetInput: "0.0",
          videoFileName: null,
          subtitlesFileName: null,
          activeCue: null,
          currentTime: 0.0,
          shouldShowVideoError: false,
          shouldShowSubtitlesError: false,
          subtitlesError: null,
          isDraggingSidebar: false,
          sideBarDragStartX: 0,
          sideBarDragDx: 0,
          sideBarX: 0.87,
          captionTracks: [],
          captions: [],
          isDraggingFile: false,
          lastActiveCaption: null,
          currentActiveCaption: null,
          isControlsExpanded: true,
          isOffsetMode: false
        },
        computed: {
          dropWrapperClass: function () {
            return this.isDraggingFile ? "dragging-file" : "";
          },
          activeCaption: function () {
            return this.cueToCaption(this.activeCue);
          },
          displayedText: function () {
            return this.activeCaption ? this.activeCaption.text : "";
          },
          subtitlesOffsetSeconds: function () {
            var num = parseFloat(this.subtitlesOffsetInput);
            return num ? num : 0.0;
          },
          captionsUrl: function () {
            if (!this.subtitlesFileContent)
              return null;

            try {
              var vtt = this.toVTT(this.subtitlesFileContent, this.subtitlesOffsetSeconds);
              if (!vtt)
                return null;

              return "data:text/vtt;charset=utf-8," + encodeURIComponent(vtt);
            } catch (error) {
              this.subtitlesError = error.message;
              this.shouldShowSubtitlesError = true;
              return null;
            }
          },
          offsetButtonClass: function () {
            return 'offset-button' + (this.isOffsetMode ? ' on' : ' off');
          },
          controlsExpandClass: function () {
            return 'controls-expand' + (this.isControlsExpanded ? ' open' : ' closed')
          }
        },
        watch: {
          activeCaption: function (newCaption, oldCaption) {
            var el = this.$el.querySelector("#" + newCaption.id);
            el.scrollIntoViewIfNeeded ? el.scrollIntoViewIfNeeded() : el.scrollIntoView({ behavior: 'smooth' });
          },
        },
        methods: {
          calcAppStyle: function () {
            return this.calcGridTemplateAreas() + this.calcGridTemplateColumns() + this.calcGridTemplateRows();
          },
          calcGridTemplateAreas: function () {
            if (!this.videoUrl && !this.captionsUrl && !this.shouldShowSubtitlesError)
              return "grid-template-areas: video";

            if (this.isControlsExpanded) {
              return "grid-template-areas: " +
              "'video resizeBar captions' " +
              "'video resizeBar controlsExpand' " +
              "'video resizeBar controls' " +
              ";";
            } else {
              return "grid-template-areas: " +
              "'video resizeBar captions' " +
              "'video resizeBar captions' " +
              "'video resizeBar controlsExpand' " +
              ";";
            }
          },
          calcGridTemplateColumns: function () {
            var leftWidth = this.sideBarX + this.sideBarDragDx;
            var middleWidth = 0;
            var rightWidth = (1 - leftWidth);
            var widths = [leftWidth, middleWidth, rightWidth]
            return "grid-template-columns: " + widths.map(function (x) { return x * 100 + "%"; }).join(" ") + ";"
          },
          calcGridTemplateRows: function () {
            if (this.isControlsExpanded)
              return 'grid-template-rows: 95.7% 0.9% 3.4%;';
            else
              return 'grid-template-rows: 95.7% 3.4% 0.9%;';
          },
          toggleControls: function () {
            this.isControlsExpanded = !this.isControlsExpanded;
          },
          toggleOffsetMode: function () {
            this.isOffsetMode = !this.isOffsetMode;
          },
          toggleTooltip: function () {
            this.shouldShowTooltip = !this.shouldShowTooltip;
          },
          onMouseMove: function (e) {
            if (!this.isDraggingSidebar) {
              this.onMouseUp();
              return;
            }
            this.sideBarDragDx = this.pixelsToFraction(e.clientX) - this.sideBarDragStartX;
          },
          onMouseUp: function (e) {
            this.isDraggingSidebar = false;
            this.sideBarDragStartX = 0;
            this.sideBarX = this.sideBarX + this.sideBarDragDx;
            this.sideBarDragDx = 0;
          },
          onMouseOut: function (e) {
            mouseX = e.pageX;
            mouseY = e.pageY;
            if ((mouseY >= 0 && mouseY <= window.innerHeight)
            && (mouseX >= 0 && mouseX <= window.innerWidth))
                return;
            this.onMouseUp(null);
            console.log("MouseUp")
          },
          onResizeBarMouseDown: function (e) {
            this.isDraggingSidebar = true;
            this.sideBarDragStartX = this.pixelsToFraction(e.clientX);
            console.log("MouseDown")
          },
          pixelsToFraction(numPixels) {
            return numPixels / this.$el.clientWidth;
          },
          onFileDragover: function (e) {
            this.isDraggingFile = true;
          },

          onFileDragleave: function (e) {
            this.isDraggingFile = false;
          },

          onFileDrop: function (e) {
            this.isDraggingFile = false;
            for (var i = 0; i < e.dataTransfer.files.length; i++) {
              var file = e.dataTransfer.files[i];
              this.isCaptions(file)
                ? this.loadCaptions(file)
                : this.loadVideo(file);
            }
          },

          loadVideo: function (file) {
            if (this.videoUrl) {
              URL.revokeObjectURL(this.videoUrl);
            }

            this.videoUrl = URL.createObjectURL(file);
            this.shouldShowVideoError = false;
            this.videoFileName = file.name;
          },

          onVideoError: function (event) {
            this.shouldShowVideoError = true;
          },

          getVideoElement: function() {
            return this.$el.querySelector("#video-element");
          },

          onTimeUpdate: function () {
            this.currentTime = this.getCurrentTime();
          },

          getCurrentTime: function() {
            var videoElement = this.getVideoElement();
            return videoElement ? videoElement.currentTime : 0;
          },

          setCurrentTime: function(time) {
            var videoElement = this.getVideoElement();
            if (videoElement) {
              videoElement.currentTime = time;
              videoElement.play();
            }
          },

          playPause: function (e) {
            var video = this.getVideoElement();
            if (video.paused) video.play();
            else video.pause();
          },

          playCue: function (cue) {
            if (!cue) return;
            this.setCurrentTime(cue.startTime);
          },

          replayCaption: function (e) {
            var track = this.getTrack();
            if (!track) return;
            this.playCue(this.activeCue || track.cues[0]);
          },

          previousCaption: function (e) {
            this.moveCaptionsBy(-1);
          },

          nextCaption: function (e) {
            this.moveCaptionsBy(1);
          },

          moveCaptionsBy: function (numCaptions) {
            var track = this.getTrack();
            if (!track) return;

            if (!this.activeCue) {
              this.replayCaption();
            }

            var index = track.cues.indexOf(this.activeCue);
            var next = track.cues[index + numCaptions];

            this.playCue(next);
          },

          isActive: function (caption) {
            return this.activeCaption && this.activeCaption.id === caption.id;
          },

          captionStyle: function (caption, index) {
            return 'caption' + (this.isActive(caption) ? ' active' : '')
          },

          displayCaptionOffset: function (caption) {
            var offset = this.calcCaptionOffset(caption);
            return (offset > 0 ? '+' : '') + this.calcCaptionOffset(caption).toFixed(2) + "s";
          },

          calcCaptionOffset: function (caption) {
            return this.currentTime - caption.endTime;
          },

          selectCaption: function (caption) {
            if (this.isOffsetMode) {
              this.subtitlesOffsetInput = (this.subtitlesOffsetSeconds + this.calcCaptionOffset(caption)).toFixed(2);
              this.isOffsetMode = false;
            } else {
              this.setCurrentTime(caption.startTime);
            }
          },

          getTrack: function () {
            var tracks = this.getVideoElement().textTracks;
            var track = tracks && tracks[0];
            if (!track) return null;

            // TODO: Do this a better way?
            track.mode = "hidden";

            return track;
          },

          cueToCaption: function (cue) {
            if (!cue) return null;

            var caption = {
              id: "id_" + cue.id,
              startTime: cue.startTime,
              endTime: cue.endTime,
              text: cue.text.replace(/\n/g, "<br>"),
            };
            if (!caption.id) {
              caption.id = JSON.stringify(caption);
            }
            return caption;
          },

          onCaptionsLoad: function (e) {
            var track = this.getTrack();
            if (!track) return;

            this.captions = Array.prototype.map.call(
              track.cues,
              this.cueToCaption
            );
          },

          onCaptionsCueChange: function (e) {
            var track = this.getTrack();
            if (!track) return;

            var cue = track.activeCues[0];
            if (cue) this.activeCue = cue;
          },

          isCaptions: function (file) {
            return /\.(vtt|srt|ass|ssa)$/i.test(file.name);
          },

          loadCaptions: function (file) {
            this.subtitlesFileName = file.name;
            this.shouldShowSubtitlesError = false;
            this.subtitlesError = null;
            var reader = new FileReader();
            reader.readAsText(file);
            var self = this;
            reader.onload = function (e) {
              self.subtitlesFileContent = reader.result;
            };
          },

          assToCaptions: function (text) {
            var reAss = new RegExp(
              "Dialogue:\\s\\d," + // get time and subtitle
              "(\\d+:\\d\\d:\\d\\d.\\d\\d)," + // start time
              "(\\d+:\\d\\d:\\d\\d.\\d\\d)," + // end time
              "([^,]*)," + // object
              "([^,]*)," + // actor
                "(?:[^,]*,){4}" +
                "(.*)$", // subtitle
              "i"
            );
            var reTime = /(\d+):(\d\d):(\d\d).(\d\d)/;
            var reStyle = /\{[^}]+\}/g;

            var getSeconds = function (timeStr) {
              var match = timeStr.match(reTime);
              return (
                Math.round(
                  parseInt(match[1], 10) * 60 * 60 * 1000 +
                    parseInt(match[2], 10) * 60 * 1000 +
                    parseInt(match[3], 10) * 1000 +
                    parseInt(match[4], 10) * 10
                ) / 1000
              );
            };

            var lines = text.split(/[\n\r]+/g);
            var captions = lines
              .map(function (line, index) {
                var match = line.match(reAss);
                if (!match) {
                  return null;
                }
                return {
                  id: index + 1,
                  startTime: getSeconds(match[1]),
                  endTime: getSeconds(match[2]),
                  text: match[5].replace(reStyle, "").replace(/\\N/g, "\n"),
                  voice: match[3] && match[4] ? match[3] + " " + match[4] : "",
                };
              })
              .filter(function (caption) {
                return caption != null;
              });

            return captions.length ? captions : null;
          },

          srtToCaptions: function (text) {
            text = text.replace(/\r/g, '');
            var reTime = /(\d\d):(\d\d):(\d\d),(\d\d\d)/;

            if (!reTime.test(text)) {
              return null;
            }

            var getSeconds = function (timeStr) {
              var match = timeStr.match(reTime);
              return (
                Math.round(
                  parseInt(match[1], 10) * 60 * 60 * 1000 +
                    parseInt(match[2], 10) * 60 * 1000 +
                    parseInt(match[3], 10) * 1000 +
                    parseInt(match[4], 10)
                ) / 1000
              );
            };

            var entries = text.split(/\n[\n]+(?=[0-9]+\n)/g);
            var captions = entries
              .map(function (entry) {
                var lines = entry.split(/\n+/g);
                if (lines.length < 3) {
                  return null;
                }
                var timestamps = lines[1].split(/\s*-->\s*/);
                return {
                  id: lines[0],
                  startTime: getSeconds(timestamps[0]),
                  endTime: getSeconds(timestamps[1]),
                  text: lines.slice(2).join("\n"),
                };
              })
              .filter(function (caption) {
                return caption != null;
              });

            return captions.length ? captions : null;
          },

          formatVtt: function (captions) {
            var padWithZeros = function (num, digits) {
              return ("0000" + num).slice(-digits);
            };

            var formatTime = function (seconds) {
              var date = new Date(2000, 0, 1, 0, 0, 0, seconds * 1000);
              return [
                padWithZeros(date.getHours(), 2),
                padWithZeros(date.getMinutes(), 2),
                padWithZeros(date.getSeconds(), 2) +
                  "." +
                  padWithZeros(date.getMilliseconds(), 3),
              ].join(":");
            };

            var lines = captions.map(function (caption) {
              return [
                caption.id,
                formatTime(caption.startTime) +
                  " --> " +
                  formatTime(caption.endTime),
                (caption.voice ? "<v " + caption.voice + ">" : "") +
                  caption.text,
              ].join("\n");
            });

            return "WEBVTT\n\n" + lines.join("\n\n");
          },

          toVTT: function (text, offset) {
            if (text.indexOf("WEBVTT") === 0) {
              return text;
            }

            var parsed = this.assToCaptions(text) || this.srtToCaptions(text);
            if (!parsed) {
              this.shouldShowSubtitlesError = true;
              this.subtitlesError = null;
              return null;
            }

            parsed.forEach(function (cue) {
              cue.startTime = Math.max(0, cue.startTime + offset);
              cue.endTime = Math.max(0, cue.endTime + offset);
            });

            return this.formatVtt(parsed);
          },
        },
      });
    </script>
  </body>
</html>
